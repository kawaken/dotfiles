#!/bin/zsh

# Git worktree management function
# gw - Git Worktree helper for efficient branch-based development

# Helper function to shorten task name for worktree path
function _gw_shorten_name() {
    local name="$1"
    local shortened="${name//\//-}"
    if [ ${#shortened} -gt 20 ]; then
        shortened="${shortened:0:18}__"
    fi
    echo "$shortened"
}

# Helper function to get worktree path for a task
function _gw_get_worktree_path() {
    local task_name="$1"
    local main_repo_path=$(git worktree list | head -n 1 | awk '{print $1}')
    local repo_name=$(basename "$main_repo_path")
    local parent_dir=$(dirname "$main_repo_path")

    if [ -z "$task_name" ] || [ "$task_name" = "main" ]; then
        echo "$main_repo_path"
    else
        local shortened_name=$(_gw_shorten_name "$task_name")
        echo "${parent_dir}/${repo_name}-${shortened_name}"
    fi
}

# Helper function to get metadata file path for a worktree
function _gw_get_metadata_path() {
    local worktree_path="$1"
    local main_repo_path=$(git worktree list | head -n 1 | awk '{print $1}')
    local worktree_name=$(basename "$worktree_path")
    echo "${main_repo_path}/.git/worktrees/${worktree_name}/gw_metadata"
}

# Helper function to get value from metadata
function _gw_get_value() {
    local worktree_path="$1"
    local key="$2"
    local metadata_path=$(_gw_get_metadata_path "$worktree_path")
    if [ -f "$metadata_path" ]; then
        grep "^${key}=" "$metadata_path" 2>/dev/null | cut -d= -f2-
    fi
}

# Helper function to set value in metadata
function _gw_set_value() {
    local worktree_path="$1"
    local key="$2"
    local value="$3"
    local metadata_path=$(_gw_get_metadata_path "$worktree_path")

    if [ -f "$metadata_path" ]; then
        local tmp=$(grep -v "^${key}=" "$metadata_path" 2>/dev/null || true)
        echo "$tmp" > "$metadata_path"
    fi
    echo "${key}=${value}" >> "$metadata_path"
}

# Helper function to get description for a worktree (wrapper)
function _gw_get_description() {
    local worktree_path="$1"
    _gw_get_value "$worktree_path" "purpose"
}

# Helper function to set description for a worktree (wrapper)
function _gw_set_description() {
    local worktree_path="$1"
    local description="$2"
    _gw_set_value "$worktree_path" "purpose" "$description"
}

# Helper function to truncate text with ellipsis
function _gw_truncate_text() {
    local text="$1"
    local max_len="$2"
    if [ ${#text} -gt $max_len ]; then
        echo "${text:0:$((max_len - 3))}..."
    else
        echo "$text"
    fi
}

# Helper function to extract PR number from URL or number
function _gw_extract_pr_number() {
    local input="$1"
    # URL: https://github.com/owner/repo/pull/123
    if [[ "$input" =~ ^https://github\.com/.+/pull/([0-9]+) ]]; then
        echo "${match[1]}"
    # #123 形式
    elif [[ "$input" =~ ^#([0-9]+)$ ]]; then
        echo "${match[1]}"
    # 数字のみ
    elif [[ "$input" =~ ^[0-9]+$ ]]; then
        echo "$input"
    else
        return 1
    fi
}

function gw() {
    case "$1" in
        create|cr)
            shift
            _gw_create "$@"
            ;;
        list|ls)
            shift
            _gw_list "$@"
            ;;
        remove|rm)
            shift
            _gw_remove "$@"
            ;;
        switch|sw)
            shift
            _gw_switch "$@"
            ;;
        describe|desc)
            shift
            _gw_describe "$@"
            ;;
        review|rv)
            shift
            _gw_review "$@"
            ;;
        *)
            echo "Usage: gw <command> [options]"
            echo ""
            echo "Commands:"
            echo "  create, cr <task> <desc> Create worktree and switch to it"
            echo "  list, ls                 List all worktrees"
            echo "  remove, rm [task]        Remove worktree (no args = current)"
            echo "  switch, sw [task|-]      Switch to worktree (no args = main, - = previous)"
            echo "  describe, desc           Show worktree info"
            echo "    --set purpose=<text>   Set purpose"
            echo "  review, rv <pr|url>      Create worktree for PR review"
            ;;
    esac
}

# Create new worktree
function _gw_create() {
    local task_name="$1"
    local description="$2"
    if [ -z "$task_name" ]; then
        echo "エラー: タスク名を指定してください"
        return 1
    fi

    if [ -z "$description" ]; then
        echo -n "目的を入力してください: "
        read -r description
        if [ -z "$description" ]; then
            echo "エラー: 目的は必須です"
            return 1
        fi
    fi

    local branch_name="$task_name"

    # Check if local branch already exists
    local local_branch_exists=false
    if git show-ref --verify --quiet "refs/heads/${branch_name}"; then
        local_branch_exists=true
    fi

    # Check if we're in a git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo "エラー: gitリポジトリではありません"
        return 1
    fi

    # Get worktree path
    local worktree_path=$(_gw_get_worktree_path "$branch_name")
    local main_repo_path=$(git worktree list | head -n 1 | awk '{print $1}')

    # Check if worktree already exists
    if [ -d "$worktree_path" ]; then
        echo "Worktree already exists. Moving to: $worktree_path"
        cd "$worktree_path"
        return 0
    fi

    # Check if remote branch exists
    local remote_exists=false
    if git ls-remote --heads origin "$branch_name" | grep -q "$branch_name"; then
        remote_exists=true
    fi
    
    # Determine branch status and show message
    if [ "$local_branch_exists" = true ]; then
        echo "既存のローカルブランチ '$branch_name' からworktreeを作成します。"
    elif [ "$remote_exists" = true ]; then
        echo "リモートブランチ '$branch_name' が見つかりました。リモートブランチからworktreeを作成します。"
    else
        echo "新しいブランチ '$branch_name' としてworktreeを作成します。"
    fi

    # Fetch and update local main branch
    echo "Fetching latest changes..."
    if ! (cd "$main_repo_path" && git fetch origin main:main); then
        echo "エラー: ローカルmainの更新に失敗しました"
        return 1
    fi

    # Create worktree - use different command based on branch existence
    echo "Creating worktree: $worktree_path"
    if [ "$local_branch_exists" = true ]; then
        # Local branch exists, just checkout
        git worktree add "$worktree_path" "$branch_name"
    elif [ "$remote_exists" = true ]; then
        # Remote branch exists, track it without -b
        git worktree add "$worktree_path" "$branch_name"
    else
        # Create new branch from local main (no upstream set)
        git worktree add -b "$branch_name" "$worktree_path" main
    fi

    # Execute .gw.sh if it exists and is executable
    if [ -x "${main_repo_path}/.gw.sh" ]; then
        "${main_repo_path}/.gw.sh" "$worktree_path"
    fi

    # Save description and original branch
    _gw_set_description "$worktree_path" "$description"
    _gw_set_value "$worktree_path" "original_branch" "$branch_name"

    # Move to new worktree
    cd "$worktree_path"

    echo "Worktree created and switched to: $worktree_path"
    echo "目的: $description"
}

# Helper function to format worktree info line
function _gw_format_worktree_line() {
    local worktree_path="$1"
    local branch="$2"
    local max_width="${3:-0}"
    local show_branch="${4:-auto}"

    local shortened_path=$(_shorten_path "$worktree_path")
    local purpose=$(_gw_get_description "$worktree_path")

    local dir_name=$(basename "$worktree_path")
    local branch_name="${branch#\[}"
    branch_name="${branch_name%\]}"

    # メインリポジトリの情報を取得
    local main_repo_path=$(git worktree list | head -n 1 | awk '{print $1}')
    local repo_name=$(basename "$main_repo_path")
    # 初期ブランチを取得
    local original_branch=$(_gw_get_value "$worktree_path" "original_branch")

    local prefix="$shortened_path"
    # メインリポジトリ + main ブランチの場合は非表示
    if [[ "$dir_name" == "$repo_name" ]] && [[ "$branch_name" == "main" ]]; then
        : # ブランチ表示しない
    # 初期ブランチと同じ場合も非表示
    elif [[ -n "$original_branch" ]] && [[ "$branch_name" == "$original_branch" ]]; then
        : # ブランチ表示しない
    elif [ "$show_branch" = "always" ] || { [ "$show_branch" = "auto" ] && [[ "$dir_name" != *"-${branch_name}" ]]; }; then
        prefix="${shortened_path} ${branch}"
    fi

    if [ "$max_width" -gt 0 ] && [ -n "$purpose" ]; then
        local prefix_len=${#prefix}
        local desc_max=$((max_width - prefix_len - 2))
        if [ $desc_max -gt 10 ]; then
            local truncated=$(_gw_truncate_text "$purpose" $desc_max)
            echo "${prefix} ${truncated}"
            return
        fi
    fi
    echo "$prefix"
}

# List worktrees
function _gw_list() {
    local term_width=${COLUMNS:-$(tput cols)}
    git worktree list | while IFS= read -r line; do
        local worktree_path=$(echo "$line" | awk '{print $1}')
        local branch=$(echo "$line" | awk '{print $3}')
        _gw_format_worktree_line "$worktree_path" "$branch" "$term_width"
    done
}

# Remove worktree
function _gw_remove() {
    local task_name="$1"
    local main_repo_path=$(git worktree list | head -n 1 | awk '{print $1}')
    local current_path=$(pwd)
    local confirm_current=false

    if [ -z "$task_name" ]; then
        if [ "$current_path" = "$main_repo_path" ]; then
            echo "エラー: main worktree は削除できません"
            return 1
        fi
        confirm_current=true
        task_name=$(basename "$current_path")
        local repo_name=$(basename "$main_repo_path")
        task_name="${task_name#${repo_name}-}"
    fi

    shift 2>/dev/null
    local additional_args=("$@")

    local worktree_path=$(_gw_get_worktree_path "$task_name")

    if [ ! -d "$worktree_path" ]; then
        echo "エラー: Worktree '$worktree_path' が存在しません"
        return 1
    fi

    if [ "$confirm_current" = true ]; then
        echo -n "現在の worktree '$worktree_path' を削除しますか? [y/N]: "
        read -r response
        case "$response" in
            [Yy]|[Yy][Ee][Ss])
                ;;
            *)
                echo "Aborted"
                return 1
                ;;
        esac
    fi

    # Check if --force is already specified
    local has_force=false
    for arg in "${additional_args[@]}"; do
        if [[ "$arg" == "--force" || "$arg" == "-f" ]]; then
            has_force=true
            break
        fi
    done

    # If --force is not specified, check for untracked/modified files
    if [ "$has_force" = false ]; then
        local status_output
        status_output=$(git -C "$worktree_path" status -sb 2>/dev/null)
        local has_changes=false

        # Check if there are any changes (lines other than the branch line)
        if echo "$status_output" | grep -q "^[^#].*[AMD??]"; then
            has_changes=true
        fi

        if [ "$has_changes" = true ]; then
            echo "Worktree contains untracked or modified files:"
            echo "$status_output"
            echo ""
            echo -n "Delete anyway? [y/N]: "
            read -r response

            case "$response" in
                [Yy]|[Yy][Ee][Ss])
                    additional_args+=("--force")
                    ;;
                *)
                    echo "Aborted"
                    return 1
                    ;;
            esac
        fi
    fi

    local current_branch=$(git -C "$worktree_path" branch --show-current 2>/dev/null)

    cd "$main_repo_path"

    git worktree remove "${additional_args[@]}" "$worktree_path"
    echo "Worktree removed: $worktree_path"

    if [[ -n "$current_branch" && "$current_branch" != "main" && "$current_branch" != "master" ]]; then
        git branch -D "$current_branch" 2>/dev/null && \
            echo "Branch deleted: $current_branch"
    fi
}

# Switch to existing worktree
function _gw_switch() {
    local task_name="$1"
    local current_path=$(pwd)

    if [ "$task_name" = "-" ]; then
        if [ -z "$GW_PREVIOUS_WORKTREE" ]; then
            echo "エラー: 以前のワークツリーがありません"
            return 1
        fi
        local worktree_path="$GW_PREVIOUS_WORKTREE"
    else
        local worktree_path=$(_gw_get_worktree_path "$task_name")
    fi

    if [ ! -d "$worktree_path" ]; then
        echo "エラー: Worktree '$worktree_path' が存在しません"
        return 1
    fi

    # Save current path as previous before switching
    export GW_PREVIOUS_WORKTREE="$current_path"

    cd "$worktree_path"
    echo "Switched to: $worktree_path"

    local description=$(_gw_get_description "$worktree_path")
    if [ -n "$description" ]; then
        echo "目的: $description"
    fi
}

# Create worktree for PR review
function _gw_review() {
    local input="$1"
    if [ -z "$input" ]; then
        echo "エラー: PR番号またはURLを指定してください"
        echo "使い方: gw review <pr-number|url>"
        return 1
    fi

    if ! command -v gh &> /dev/null; then
        echo "エラー: gh コマンドが見つかりません"
        return 1
    fi

    local pr_number=$(_gw_extract_pr_number "$input")
    if [ -z "$pr_number" ]; then
        echo "エラー: PR番号を抽出できませんでした: $input"
        return 1
    fi

    local pr_info
    pr_info=$(gh pr view "$pr_number" --json number,title,headRefName,url 2>&1)
    if [ $? -ne 0 ]; then
        echo "エラー: PR情報の取得に失敗しました"
        echo "$pr_info"
        return 1
    fi

    local pr_title=$(echo "$pr_info" | jq -r '.title')
    local pr_branch=$(echo "$pr_info" | jq -r '.headRefName')
    local pr_url=$(echo "$pr_info" | jq -r '.url')

    local main_repo_path=$(git worktree list | head -n 1 | awk '{print $1}')
    local repo_name=$(basename "$main_repo_path")
    local parent_dir=$(dirname "$main_repo_path")
    local pr_container="${parent_dir}/${repo_name}-PR"
    local worktree_path="${pr_container}/${pr_number}"

    if [ -d "$worktree_path" ]; then
        echo "既存のworktreeに移動します: $worktree_path"
        cd "$worktree_path"
        return 0
    fi

    if [ ! -d "$pr_container" ]; then
        mkdir -p "$pr_container"
    fi

    echo "PRブランチをfetchしています..."
    if ! (cd "$main_repo_path" && git fetch origin "$pr_branch"); then
        echo "エラー: ブランチのfetchに失敗しました"
        return 1
    fi

    echo "Worktreeを作成しています: $worktree_path"
    if ! git worktree add "$worktree_path" "$pr_branch"; then
        echo "エラー: worktreeの作成に失敗しました"
        return 1
    fi

    if [ -x "${main_repo_path}/.gw.sh" ]; then
        "${main_repo_path}/.gw.sh" "$worktree_path"
    fi

    _gw_set_value "$worktree_path" "pr_number" "$pr_number"
    _gw_set_value "$worktree_path" "pr_title" "$pr_title"
    _gw_set_value "$worktree_path" "pr_url" "$pr_url"
    _gw_set_value "$worktree_path" "original_branch" "$pr_branch"
    _gw_set_value "$worktree_path" "purpose" "#${pr_number}: ${pr_title}"

    cd "$worktree_path"
    echo "PR #${pr_number} のworktreeを作成しました: $worktree_path"
    echo "タイトル: $pr_title"
}

# Show or set description for current worktree
function _gw_describe() {
    local current_path=$(pwd)

    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo "エラー: gitリポジトリではありません"
        return 1
    fi

    if [ "$1" = "--set" ]; then
        local key_value="$2"
        if [ -z "$key_value" ]; then
            echo "エラー: --set には key=value を指定してください"
            return 1
        fi

        local key="${key_value%%=*}"
        local value="${key_value#*=}"

        case "$key" in
            purpose|original_branch)
                if [ -z "$value" ]; then
                    echo "エラー: 値を指定してください"
                    return 1
                fi
                _gw_set_value "$current_path" "$key" "$value"
                echo "${key}を設定しました: $value"
                ;;
            *)
                echo "エラー: 不明なキー '$key'"
                echo "設定可能なキー: purpose, original_branch"
                return 1
                ;;
        esac
    else
        local branch=$(git branch --show-current)
        local purpose=$(_gw_get_description "$current_path")
        local original_branch=$(_gw_get_value "$current_path" "original_branch")
        local pr_number=$(_gw_get_value "$current_path" "pr_number")
        local pr_url=$(_gw_get_value "$current_path" "pr_url")

        echo "path: $current_path"
        echo "branch: $branch"
        echo "purpose: ${purpose:-（未設定）}"
        echo "original_branch: ${original_branch:-（未設定）}"
        if [ -n "$pr_number" ]; then
            echo "pr_number: $pr_number"
            echo "pr_url: $pr_url"
        fi
    fi
}

# Completion function
function _gw() {
    local -a subcommands
    local state

    subcommands=(
        'create:Create new worktree and switch to it'
        'cr:Create new worktree (alias)'
        'list:List all worktrees'
        'ls:List worktrees (alias)'
        'remove:Remove worktree'
        'rm:Remove worktree (alias)'
        'switch:Switch to worktree'
        'sw:Switch to worktree (alias)'
        'describe:Show or set description'
        'desc:Show or set description (alias)'
        'review:Create worktree for PR review'
        'rv:Create worktree for PR review (alias)'
    )

    _arguments -C \
        '1: :->command' \
        '2: :->args'

    case $state in
        command)
            _describe -t commands 'gw subcommand' subcommands
            ;;
        args)
            case $words[2] in
                remove|rm|switch|sw)
                    _gw_worktree_tasks
                    ;;
                create|cr|review|rv)
                    ;;
            esac
            ;;
    esac
}

# Helper function to complete worktree task names
function _gw_worktree_tasks() {
    local -a tasks
    local main_repo_path repo_name

    main_repo_path=$(git worktree list 2>/dev/null | head -n 1 | awk '{print $1}')
    [[ -z "$main_repo_path" ]] && return

    repo_name=$(basename "$main_repo_path")
    tasks=("main")

    local worktree_paths=(${(f)"$(git worktree list 2>/dev/null | awk 'NR>1 {print $1}')"})
    for wt_path in "${worktree_paths[@]}"; do
        local dir_name=$(basename "$wt_path")
        if [[ "$dir_name" == "${repo_name}-"* ]]; then
            tasks+=("${dir_name#${repo_name}-}")
        fi
    done

    [[ ${#tasks[@]} -gt 0 ]] && _describe -t tasks 'worktree task' tasks
}

# Register completion
if (( $+functions[compdef] )); then
    compdef _gw gw
fi
