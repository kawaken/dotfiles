#!/bin/zsh

# Git worktree management function
# gw - Git Worktree helper for efficient branch-based development

# ─── Helpers ───────────────────────────────────────────────

# Get the main (first) worktree path
function _gw_main_repo_path() {
    git worktree list | head -n 1 | awk '{print $1}'
}

# Shorten task name for worktree path
function _gw_shorten_name() {
    local name="$1"
    local shortened="${name//\//-}"
    if [ ${#shortened} -gt 20 ]; then
        shortened="${shortened:0:18}__"
    fi
    echo "$shortened"
}

# Get worktree path for a task
function _gw_get_worktree_path() {
    local task_name="$1"
    local main_repo_path=$(_gw_main_repo_path)
    local repo_name=$(basename "$main_repo_path")
    local parent_dir=$(dirname "$main_repo_path")

    if [ -z "$task_name" ] || [ "$task_name" = "main" ]; then
        echo "$main_repo_path"
    else
        local shortened_name=$(_gw_shorten_name "$task_name")
        echo "${parent_dir}/${repo_name}-${shortened_name}"
    fi
}

# Get metadata file path for a worktree
function _gw_get_metadata_path() {
    local worktree_path="$1"
    local main_repo_path=$(_gw_main_repo_path)
    local worktree_name=$(basename "$worktree_path")
    echo "${main_repo_path}/.git/worktrees/${worktree_name}/gw_metadata"
}

# Get value from metadata
function _gw_get_value() {
    local worktree_path="$1"
    local key="$2"
    local metadata_path=$(_gw_get_metadata_path "$worktree_path")
    if [ -f "$metadata_path" ]; then
        grep "^${key}=" "$metadata_path" 2>/dev/null | cut -d= -f2-
    fi
}

# Set value in metadata
function _gw_set_value() {
    local worktree_path="$1"
    local key="$2"
    local value="$3"
    local metadata_path=$(_gw_get_metadata_path "$worktree_path")

    if [ -f "$metadata_path" ]; then
        local tmp=$(grep -v "^${key}=" "$metadata_path" 2>/dev/null || true)
        if [ -n "$tmp" ]; then
            echo "$tmp" > "$metadata_path"
        else
            : > "$metadata_path"
        fi
    fi
    echo "${key}=${value}" >> "$metadata_path"
}

# Get description for a worktree (wrapper)
function _gw_get_description() {
    local worktree_path="$1"
    _gw_get_value "$worktree_path" "purpose"
}

# Generate a short label for a worktree
function _gw_make_label() {
    local wt_path="$1"
    local repo_name="$2"
    local dir_name=$(basename "$wt_path")
    local parent_name=$(basename "$(dirname "$wt_path")")

    if [[ "$parent_name" == "${repo_name}-PR" ]]; then
        echo "PR-${dir_name}"
    elif [[ "$dir_name" == "${repo_name}-"* ]]; then
        echo "${dir_name#${repo_name}-}"
    elif [[ "$dir_name" == "$repo_name" ]]; then
        echo "main"
    else
        echo "$dir_name"
    fi
}

# Resolve worktree path from query using git worktree list
function _gw_resolve_worktree() {
    local query="$1"
    local main_repo_path=$(_gw_main_repo_path)
    local repo_name=$(basename "$main_repo_path")

    if [ -z "$query" ] || [ "$query" = "main" ]; then
        echo "$main_repo_path"
        return 0
    fi

    local worktree_paths=(${(f)"$(git worktree list | awk '{print $1}')"})
    local dir_name parent_name q
    for wt_path in "${worktree_paths[@]}"; do
        dir_name=$(basename "$wt_path")
        parent_name=$(basename "$(dirname "$wt_path")")

        # Exact match: basename matches query
        if [ "$dir_name" = "$query" ]; then
            echo "$wt_path"
            return 0
        fi
        # ${repo_name}-${query} pattern
        if [ "$dir_name" = "${repo_name}-${query}" ]; then
            echo "$wt_path"
            return 0
        fi
        # PR worktree: parent is ${repo_name}-PR and basename is query
        # Match PR-123, #123, or 123
        q="${query#PR-}"
        q="${q#\#}"
        if [ "$parent_name" = "${repo_name}-PR" ] && [ "$dir_name" = "$q" ]; then
            echo "$wt_path"
            return 0
        fi
    done
    return 1
}

# Extract PR number from URL or number
function _gw_extract_pr_number() {
    local input="$1"
    # URL: https://github.com/owner/repo/pull/123
    if [[ "$input" =~ ^https://github\.com/.+/pull/([0-9]+) ]]; then
        echo "${match[1]}"
    # #123 format
    elif [[ "$input" =~ ^#([0-9]+)$ ]]; then
        echo "${match[1]}"
    # Number only
    elif [[ "$input" =~ ^[0-9]+$ ]]; then
        echo "$input"
    else
        return 1
    fi
}

# Sync files listed in .gw-sync-files from source to destination
function _gw_sync_files() {
    local from="$1"
    local to="$2"
    local sync_file="${from}/.gw-sync-files"

    [ ! -f "$sync_file" ] && return 0

    local file

    # copy
    for file in ${(f)"$(awk '/^copy:/ { sub(/^copy:[[:space:]]*/, ""); print }' "$sync_file")"}; do
        [ ! -e "${from}/${file}" ] && continue
        mkdir -p "$(dirname "${to}/${file}")"
        if ! cp -n "${from}/${file}" "${to}/${file}"; then
            echo "Error: failed to copy '${file}'"
            return 1
        fi
    done

    # symlink
    for file in ${(f)"$(awk '/^symlink:/ { sub(/^symlink:[[:space:]]*/, ""); print }' "$sync_file")"}; do
        [ ! -e "${from}/${file}" ] && continue
        { [ -L "${to}/${file}" ] || [ -e "${to}/${file}" ]; } && continue
        mkdir -p "$(dirname "${to}/${file}")"
        if ! ln -s "${from}/${file}" "${to}/${file}"; then
            echo "Error: failed to symlink '${file}'"
            return 1
        fi
    done
}

# Set up a new worktree (sync files, run hooks, write metadata)
function _gw_setup_worktree() {
    local worktree_path="$1"
    shift
    local main_repo_path=$(_gw_main_repo_path)

    if ! _gw_sync_files "$main_repo_path" "$worktree_path"; then
        return 1
    fi

    if [ -x "${main_repo_path}/.gw.sh" ]; then
        echo "=== Running .gw.sh ==="
        "${main_repo_path}/.gw.sh" "$worktree_path" || return 1
        echo "=== Done .gw.sh ==="
    fi

    local key value
    for kv in "$@"; do
        key="${kv%%=*}"
        value="${kv#*=}"
        if ! _gw_set_value "$worktree_path" "$key" "$value"; then
            echo "Error: failed to write metadata key '${key}'"
            return 1
        fi
    done

    cd "$worktree_path"
}

# Format worktree info line
# Args: worktree_path branch label [show_branch]
function _gw_format_worktree_line() {
    local worktree_path="$1"
    local branch="$2"
    local label="$3"
    local show_branch="${4:-auto}"

    local purpose=$(_gw_get_description "$worktree_path")
    local age
    age=$(git -C "$worktree_path" log -1 --format='%cr' 2>/dev/null)
    age="${age% ago}"

    local branch_name="${branch#\[}"
    branch_name="${branch_name%\]}"
    local original_branch=$(_gw_get_value "$worktree_path" "original_branch")

    local left="${label}"
    [[ -n "$age" ]] && left="${label} (${age})"

    local right=""
    if [[ "$label" == "main" ]] && [[ "$branch_name" == "main" ]]; then
        :
    elif [[ -n "$original_branch" ]] && [[ "$branch_name" == "$original_branch" ]]; then
        :
    elif [[ "$label" == "$branch_name" ]]; then
        :
    elif [ "$show_branch" = "always" ] || [ "$show_branch" = "auto" ]; then
        right="${branch}"
    fi

    [[ -n "$purpose" ]] && right="${right:+${right} }${purpose}"

    if [[ -n "$right" ]]; then
        printf '%s\t%s\n' "$left" "$right"
    else
        printf '%s\n' "$left"
    fi
}

# Remove single worktree (internal)
function _gw_remove_single() {
    local worktree_path="$1"
    local confirm_current="$2"
    local has_force="$3"
    local main_repo_path="$4"
    local response remove_opts=() status_output current_branch

    if [[ ! -d "$worktree_path" ]]; then
        echo "Error: worktree '$worktree_path' does not exist"
        return 1
    fi

    if [[ "$confirm_current" == "true" ]]; then
        echo -n "Delete current worktree '$worktree_path'? [y/N]: "
        read -r response
        case "$response" in
            [Yy]|[Yy][Ee][Ss]) ;;
            *)
                echo "Aborted"
                return 1
                ;;
        esac
    fi

    if [[ "$has_force" == "true" ]]; then
        remove_opts+=("--force")
    else
        status_output=$(git -C "$worktree_path" status -sb 2>/dev/null)
        if echo "$status_output" | grep -q "^[^#].*[AMD??]"; then
            echo "Worktree contains untracked or modified files: $worktree_path"
            echo "$status_output"
            echo ""
            echo -n "Delete anyway? [y/N]: "
            read -r response
            case "$response" in
                [Yy]|[Yy][Ee][Ss]) remove_opts+=("--force") ;;
                *)
                    echo "Skipped: $worktree_path"
                    return 1
                    ;;
            esac
        fi
    fi

    current_branch=$(git -C "$worktree_path" branch --show-current 2>/dev/null)

    cd "$main_repo_path"

    if ! git worktree remove "${remove_opts[@]}" "$worktree_path"; then
        echo "Error: failed to remove worktree: $worktree_path"
        return 1
    fi

    echo "Worktree removed: $worktree_path"

    if [[ -n "$current_branch" && "$current_branch" != "main" && "$current_branch" != "master" ]]; then
        if git branch -D "$current_branch" 2>/dev/null; then
            echo "Branch deleted: $current_branch"
        else
            echo "Note: branch '$current_branch' was not deleted (may be in use elsewhere)"
        fi
    fi
}

# ─── Subcommands ───────────────────────────────────────────

# Create new worktree
function _gw_create() {
    local task_name="$1"
    local description="$2"
    if [ -z "$task_name" ]; then
        echo "Error: task name is required"
        return 1
    fi

    if [ -z "$description" ]; then
        echo -n "Enter purpose: "
        read -r description
        if [ -z "$description" ]; then
            echo "Error: purpose is required"
            return 1
        fi
    fi

    local branch_name="$task_name"

    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo "Error: not a git repository"
        return 1
    fi

    # Check if local branch already exists
    local local_branch_exists=false
    if git show-ref --verify --quiet "refs/heads/${branch_name}"; then
        local_branch_exists=true
    fi

    local worktree_path=$(_gw_get_worktree_path "$branch_name")
    local main_repo_path=$(_gw_main_repo_path)

    if [ -d "$worktree_path" ]; then
        echo "Worktree already exists. Moving to: $worktree_path"
        cd "$worktree_path"
        return 0
    fi

    # Check if remote branch exists
    local remote_exists=false
    if git ls-remote --heads origin "$branch_name" | grep -q "refs/heads/${branch_name}$"; then
        remote_exists=true
    fi

    if [ "$local_branch_exists" = true ]; then
        echo "Creating worktree from existing local branch '$branch_name'."
    elif [ "$remote_exists" = true ]; then
        echo "Remote branch '$branch_name' found. Creating worktree from remote branch."
    else
        echo "Creating worktree with new branch '$branch_name'."
    fi

    echo "Updating local main branch..."
    local main_checked_out=$(cd "$main_repo_path" && git branch --show-current)
    if [ "$main_checked_out" = "main" ]; then
        if ! (cd "$main_repo_path" && git pull origin main); then
            echo "Error: failed to update local main"
            return 1
        fi
    else
        if ! (cd "$main_repo_path" && git fetch origin main:main); then
            echo "Error: failed to update local main"
            return 1
        fi
    fi

    if [ "$remote_exists" = true ] && [ "$local_branch_exists" = false ]; then
        echo "Fetching remote branch..."
        if ! (cd "$main_repo_path" && git fetch origin "$branch_name"); then
            echo "Error: failed to fetch branch '$branch_name'"
            return 1
        fi
    fi

    echo "Creating worktree: $worktree_path"
    if [ "$local_branch_exists" = true ] || [ "$remote_exists" = true ]; then
        if ! git worktree add "$worktree_path" "$branch_name"; then
            return 1
        fi
    else
        if ! git worktree add -b "$branch_name" "$worktree_path" main; then
            return 1
        fi
    fi

    if ! _gw_setup_worktree "$worktree_path" \
        "purpose=${description}" \
        "original_branch=${branch_name}"; then
        echo "Error: worktree created but setup failed"
        return 1
    fi
    echo "Worktree created and switched to: $worktree_path"
}

# List worktrees
function _gw_list() {
    local main_repo_path
    main_repo_path=$(_gw_main_repo_path)
    local repo_name=$(basename "$main_repo_path")
    local lines=(${(f)"$(git worktree list)"})
    local worktree_path branch label
    for line in "${lines[@]}"; do
        worktree_path=$(echo "$line" | awk '{print $1}')
        branch=$(echo "$line" | awk '{print $3}')
        label=$(_gw_make_label "$worktree_path" "$repo_name")
        _gw_format_worktree_line "$worktree_path" "$branch" "$label"
    done
}

# Remove worktree
function _gw_remove() {
    local main_repo_path
    main_repo_path=$(_gw_main_repo_path)
    local current_path
    current_path=$(git rev-parse --show-toplevel 2>/dev/null || pwd)
    local opts=() task_names=() worktree_paths=()
    local arg wt_path has_force=false confirm_current
    local current_wt_index i current_wt failed

    for arg in "$@"; do
        case "$arg" in
            -*) opts+=("$arg") ;;
            *) task_names+=("$arg") ;;
        esac
    done

    for arg in "${opts[@]}"; do
        if [[ "$arg" == "--force" || "$arg" == "-f" ]]; then
            has_force=true
            break
        fi
    done

    if [[ ${#task_names[@]} -eq 0 ]]; then
        if [[ "$current_path" == "$main_repo_path" ]]; then
            echo "Error: cannot remove main worktree"
            return 1
        fi
        if ! git worktree list | awk '{print $1}' | grep -qxF "$current_path"; then
            echo "Error: current directory is not a worktree"
            return 1
        fi
        _gw_remove_single "$current_path" true "$has_force" "$main_repo_path"
        return $?
    fi

    for arg in "${task_names[@]}"; do
        wt_path=$(_gw_resolve_worktree "$arg")
        if [[ $? -ne 0 ]] || [[ -z "$wt_path" ]]; then
            echo "Error: worktree '$arg' not found"
            return 1
        fi
        if [[ "$wt_path" == "$main_repo_path" ]]; then
            echo "Error: cannot remove main worktree: $arg"
            return 1
        fi
        worktree_paths+=("$wt_path")
    done

    current_wt_index=-1
    i=1
    for wt_path in "${worktree_paths[@]}"; do
        if [[ "$wt_path" == "$current_path" ]]; then
            current_wt_index=$i
            break
        fi
        (( i++ ))
    done

    if [[ $current_wt_index -ge 1 ]]; then
        current_wt="${worktree_paths[$current_wt_index]}"
        worktree_paths[$current_wt_index]=()
        worktree_paths+=("$current_wt")
    fi

    failed=0
    for wt_path in "${worktree_paths[@]}"; do
        confirm_current=false
        [[ "$wt_path" == "$current_path" ]] && confirm_current=true
        _gw_remove_single "$wt_path" "$confirm_current" "$has_force" "$main_repo_path" || (( failed++ ))
    done

    [[ $failed -gt 0 ]] && return 1
    return 0
}

# Switch to existing worktree
function _gw_switch() {
    local task_name="$1"
    local current_path=$(pwd)

    if [ "$task_name" = "-" ]; then
        if [ -z "$GW_PREVIOUS_WORKTREE" ]; then
            echo "Error: no previous worktree"
            return 1
        fi
        local worktree_path="$GW_PREVIOUS_WORKTREE"
    else
        local worktree_path=$(_gw_resolve_worktree "$task_name")
        if [ $? -ne 0 ] || [ -z "$worktree_path" ]; then
            echo "Error: worktree '$task_name' not found"
            return 1
        fi
    fi

    if [ ! -d "$worktree_path" ]; then
        echo "Error: worktree '$worktree_path' does not exist"
        return 1
    fi

    export GW_PREVIOUS_WORKTREE="$current_path"

    cd "$worktree_path"
    echo "Switched to: $worktree_path"

    local description=$(_gw_get_description "$worktree_path")
    if [ -n "$description" ]; then
        echo "Purpose: $description"
    fi
}

# Create worktree for PR review
function _gw_review() {
    local input="$1"
    if [ -z "$input" ]; then
        echo "Error: PR number or URL is required"
        echo "Usage: gw pr <pr-number|url>"
        return 1
    fi

    if ! command -v gh &> /dev/null; then
        echo "Error: gh command not found"
        return 1
    fi

    local pr_number=$(_gw_extract_pr_number "$input")
    if [ -z "$pr_number" ]; then
        echo "Error: could not extract PR number: $input"
        return 1
    fi

    local pr_info
    pr_info=$(gh pr view "$pr_number" --json number,title,headRefName,url 2>&1)
    if [ $? -ne 0 ]; then
        echo "Error: failed to get PR info"
        echo "$pr_info"
        return 1
    fi

    local pr_title=$(echo "$pr_info" | jq -r '.title')
    local pr_branch=$(echo "$pr_info" | jq -r '.headRefName')
    local pr_url=$(echo "$pr_info" | jq -r '.url')

    local main_repo_path=$(_gw_main_repo_path)
    local repo_name=$(basename "$main_repo_path")
    local parent_dir=$(dirname "$main_repo_path")
    local pr_container="${parent_dir}/${repo_name}-PR"
    local worktree_path="${pr_container}/${pr_number}"

    if [ -d "$worktree_path" ]; then
        echo "Moving to existing worktree: $worktree_path"
        cd "$worktree_path"
        return 0
    fi

    if [ ! -d "$pr_container" ]; then
        mkdir -p "$pr_container"
    fi

    echo "Fetching PR head..."
    if ! (cd "$main_repo_path" && git fetch origin "pull/${pr_number}/head"); then
        echo "Error: failed to fetch PR #${pr_number}"
        return 1
    fi

    echo "Creating worktree: $worktree_path"
    if ! git worktree add "$worktree_path" FETCH_HEAD; then
        echo "Error: failed to create worktree"
        return 1
    fi

    if ! _gw_setup_worktree "$worktree_path" \
        "purpose=#${pr_number}: ${pr_title}" \
        "original_branch=${pr_branch}" \
        "pr_number=${pr_number}" \
        "pr_title=${pr_title}" \
        "pr_url=${pr_url}"; then
        echo "Error: worktree created but setup failed"
        return 1
    fi
    echo "Created worktree for PR #${pr_number}: $worktree_path"
    echo "Title: $pr_title"
}

# Show or set description for current worktree
function _gw_describe() {
    local current_path=$(pwd)

    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo "Error: not a git repository"
        return 1
    fi

    if [ "$1" = "--set" ]; then
        local key_value="$2"
        if [ -z "$key_value" ]; then
            echo "Error: --set requires key=value"
            return 1
        fi

        local key="${key_value%%=*}"
        local value="${key_value#*=}"

        case "$key" in
            purpose|original_branch)
                if [ -z "$value" ]; then
                    echo "Error: value is required"
                    return 1
                fi
                if ! _gw_set_value "$current_path" "$key" "$value"; then
                    echo "Error: failed to set ${key}"
                    return 1
                fi
                echo "Set ${key}: $value"
                ;;
            *)
                echo "Error: unknown key '$key'"
                echo "Available keys: purpose, original_branch"
                return 1
                ;;
        esac
    else
        local branch=$(git branch --show-current)
        local purpose=$(_gw_get_description "$current_path")
        local original_branch=$(_gw_get_value "$current_path" "original_branch")
        local pr_number=$(_gw_get_value "$current_path" "pr_number")
        local pr_url=$(_gw_get_value "$current_path" "pr_url")

        echo "path: $current_path"
        echo "branch: $branch"
        echo "purpose: ${purpose:-(not set)}"
        echo "original_branch: ${original_branch:-(not set)}"
        if [ -n "$pr_number" ]; then
            echo "pr_number: $pr_number"
            echo "pr_url: $pr_url"
        fi
    fi
}

# Prune worktrees interactively
function _gw_prune() {
    if ! command -v fzf &> /dev/null; then
        echo "Error: fzf command not found"
        return 1
    fi

    local older_days=0
    if [[ "$1" == "--older" ]]; then
        if [[ "$2" =~ ^[0-9]+$ ]]; then
            older_days="$2"
            shift 2
        else
            older_days=7
            shift 1
        fi
    fi

    local main_repo_path
    main_repo_path=$(_gw_main_repo_path)
    local repo_name=$(basename "$main_repo_path")
    local candidates=()
    local now=$(date +%s)

    local worktree_lines=(${(f)"$(git worktree list)"})
    local wt_path branch label formatted commit_ts elapsed_days
    for line in "${worktree_lines[@]}"; do
        wt_path=$(echo "$line" | awk '{print $1}')
        branch=$(echo "$line" | awk '{print $3}')

        if [ "$wt_path" = "$main_repo_path" ]; then
            continue
        fi

        if [[ $older_days -gt 0 ]]; then
            commit_ts=$(git -C "$wt_path" log -1 --format='%ct' 2>/dev/null)
            if [[ -z "$commit_ts" ]]; then
                continue
            fi
            elapsed_days=$(( (now - commit_ts) / 86400 ))
            if [[ $elapsed_days -lt $older_days ]]; then
                continue
            fi
        fi

        label=$(_gw_make_label "$wt_path" "$repo_name")
        formatted=$(_gw_format_worktree_line "$wt_path" "$branch" "$label")
        candidates+=("${formatted}"$'\x1f'"${wt_path}")
    done

    if [ ${#candidates[@]} -eq 0 ]; then
        echo "No worktrees to prune"
        return 0
    fi

    local selected
    selected=$(printf '%s\n' "${candidates[@]}" | \
        fzf --multi \
            --no-mouse \
            --height='~40%' \
            --header='Tab: toggle, Ctrl-A: select all, Ctrl-D: deselect all, Enter: delete, ESC: cancel' \
            --bind 'ctrl-a:select-all,ctrl-d:deselect-all' \
            --with-nth=1 \
            --delimiter=$'\x1f')

    if [ -z "$selected" ]; then
        echo "Cancelled"
        return 0
    fi

    local selected_lines=(${(f)"$selected"})
    local failed=0
    for line in "${selected_lines[@]}"; do
        wt_path="${line##*$'\x1f'}"
        if [ -z "$wt_path" ] || [ ! -d "$wt_path" ]; then
            continue
        fi
        _gw_remove_single "$wt_path" "false" "false" "$main_repo_path" || (( failed++ ))
    done
    [[ $failed -gt 0 ]] && return 1
}

# Install .gw.sh template to repository root
function _gw_setup_template() {
    local main_repo_path=$(_gw_main_repo_path)
    local template="${${(%):-%x}:A:h}/../templates/.gw.sh.template"

    if [ ! -f "$template" ]; then
        echo "Error: template not found: $template"
        return 1
    fi

    if [ -f "${main_repo_path}/.gw.sh" ]; then
        echo -n "Overwrite existing .gw.sh? [y/N]: "
        read -r response
        case "$response" in
            [Yy]|[Yy][Ee][Ss]) ;;
            *) echo "Aborted"; return 1 ;;
        esac
    fi
    if ! cp -v "$template" "${main_repo_path}/.gw.sh"; then
        echo "Error: failed to install .gw.sh"
        return 1
    fi
    if ! chmod +x "${main_repo_path}/.gw.sh"; then
        echo "Error: failed to make .gw.sh executable"
        return 1
    fi
}

# ─── Dispatcher ────────────────────────────────────────────

function gw() {
    case "$1" in
        create|cr)
            shift
            _gw_create "$@"
            ;;
        list|ls)
            shift
            _gw_list "$@"
            ;;
        remove|rm)
            shift
            _gw_remove "$@"
            ;;
        switch|sw)
            shift
            _gw_switch "$@"
            ;;
        describe|desc)
            shift
            _gw_describe "$@"
            ;;
        pr)
            shift
            _gw_review "$@"
            ;;
        prune)
            shift
            _gw_prune "$@"
            ;;
        setup)
            shift
            _gw_setup_template "$@"
            ;;
        *)
            echo "Usage: gw <command> [options]"
            echo ""
            echo "Commands:"
            echo "  create, cr <task> <desc> Create worktree and switch to it"
            echo "  list, ls                 List all worktrees"
            echo "  remove, rm [task...]     Remove worktree(s) (no args = current)"
            echo "  switch, sw [task|-]      Switch to worktree (no args = main, - = previous)"
            echo "  describe, desc           Show worktree info"
            echo "    --set purpose=<text>   Set purpose"
            echo "  pr <pr|url>              Create worktree for PR review"
            echo "  prune [--older N]        Select and remove worktrees (--older N: show only N+ days old, default 7)"
            echo "  setup                    Install .gw.sh template to repository"
            ;;
    esac
}

# ─── Completion ────────────────────────────────────────────

# Complete worktree task names
function _gw_worktree_tasks() {
    local -a tasks
    local main_repo_path repo_name

    main_repo_path=$(_gw_main_repo_path 2>/dev/null)
    [[ -z "$main_repo_path" ]] && return

    repo_name=$(basename "$main_repo_path")
    tasks=("main")

    local worktree_paths=(${(f)"$(git worktree list 2>/dev/null | awk 'NR>1 {print $1}')"})
    local purpose wt_label age desc
    for wt_path in "${worktree_paths[@]}"; do
        wt_label=$(_gw_make_label "$wt_path" "$repo_name")
        purpose=$(_gw_get_description "$wt_path")
        age=$(git -C "$wt_path" log -1 --format='%cr' 2>/dev/null)
        age="${age% ago}"

        desc=""
        [[ -n "$age" ]] && desc="(${age})"
        [[ -n "$purpose" ]] && desc="${desc:+${desc} }${purpose}"

        if [[ -n "$desc" ]]; then
            tasks+=("${wt_label}:${desc//:/\\:}")
        else
            tasks+=("$wt_label")
        fi
    done

    [[ ${#tasks[@]} -gt 0 ]] && _describe -t tasks 'worktree task' tasks
}

# Completion function
function _gw() {
    local -a subcommands
    local state

    subcommands=(
        'create:Create new worktree and switch to it'
        'cr:Create new worktree (alias)'
        'list:List all worktrees'
        'ls:List worktrees (alias)'
        'remove:Remove worktree'
        'rm:Remove worktree (alias)'
        'switch:Switch to worktree'
        'sw:Switch to worktree (alias)'
        'describe:Show or set description'
        'desc:Show or set description (alias)'
        'pr:Create worktree for PR review'
        'prune:Select and remove worktrees interactively'
        'setup:Install .gw.sh template'
    )

    _arguments -C \
        '1: :->command' \
        '*: :->args'

    case $state in
        command)
            _describe -t commands 'gw subcommand' subcommands
            ;;
        args)
            case $words[2] in
                remove|rm|switch|sw)
                    _gw_worktree_tasks
                    ;;
                create|cr|pr)
                    ;;
            esac
            ;;
    esac
}

# Register completion
if (( $+functions[compdef] )); then
    compdef _gw gw
fi
