#!/bin/zsh

# Git worktree management function
# gw - Git Worktree helper for efficient branch-based development

# Helper function to shorten task name for worktree path
function _gw_shorten_name() {
    local name="$1"
    local shortened="${name//\//-}"
    if [ ${#shortened} -gt 20 ]; then
        shortened="${shortened:0:18}__"
    fi
    echo "$shortened"
}

# Helper function to get worktree path for a task
function _gw_get_worktree_path() {
    local task_name="$1"
    local main_repo_path=$(git worktree list | head -n 1 | awk '{print $1}')
    local repo_name=$(basename "$main_repo_path")
    local parent_dir=$(dirname "$main_repo_path")

    if [ -z "$task_name" ] || [ "$task_name" = "main" ]; then
        echo "$main_repo_path"
    else
        local shortened_name=$(_gw_shorten_name "$task_name")
        echo "${parent_dir}/${repo_name}-${shortened_name}"
    fi
}

# Helper function to get metadata file path for a worktree
function _gw_get_metadata_path() {
    local worktree_path="$1"
    local main_repo_path=$(git worktree list | head -n 1 | awk '{print $1}')
    local worktree_name=$(basename "$worktree_path")
    echo "${main_repo_path}/.git/worktrees/${worktree_name}/gw_metadata"
}

# Helper function to get value from metadata
function _gw_get_value() {
    local worktree_path="$1"
    local key="$2"
    local metadata_path=$(_gw_get_metadata_path "$worktree_path")
    if [ -f "$metadata_path" ]; then
        grep "^${key}=" "$metadata_path" 2>/dev/null | cut -d= -f2-
    fi
}

# Helper function to set value in metadata
function _gw_set_value() {
    local worktree_path="$1"
    local key="$2"
    local value="$3"
    local metadata_path=$(_gw_get_metadata_path "$worktree_path")

    if [ -f "$metadata_path" ]; then
        local tmp=$(grep -v "^${key}=" "$metadata_path" 2>/dev/null || true)
        if [ -n "$tmp" ]; then
            echo "$tmp" > "$metadata_path"
        else
            : > "$metadata_path"
        fi
    fi
    echo "${key}=${value}" >> "$metadata_path"
}

# Helper function to get description for a worktree (wrapper)
function _gw_get_description() {
    local worktree_path="$1"
    _gw_get_value "$worktree_path" "purpose"
}

# Helper function to set description for a worktree (wrapper)
function _gw_set_description() {
    local worktree_path="$1"
    local description="$2"
    _gw_set_value "$worktree_path" "purpose" "$description"
}

# Helper function to truncate text with ellipsis
function _gw_truncate_text() {
    local text="$1"
    local max_len="$2"
    if [ ${#text} -gt $max_len ]; then
        echo "${text:0:$((max_len - 3))}..."
    else
        echo "$text"
    fi
}

# Helper function to resolve worktree path from query using git worktree list
function _gw_resolve_worktree() {
    local query="$1"
    local main_repo_path=$(git worktree list | head -n 1 | awk '{print $1}')
    local repo_name=$(basename "$main_repo_path")

    if [ -z "$query" ] || [ "$query" = "main" ]; then
        echo "$main_repo_path"
        return 0
    fi

    local worktree_paths=(${(f)"$(git worktree list | awk '{print $1}')"})
    local dir_name parent_name q
    for wt_path in "${worktree_paths[@]}"; do
        dir_name=$(basename "$wt_path")
        parent_name=$(basename "$(dirname "$wt_path")")

        # 完全一致: basename が query と一致
        if [ "$dir_name" = "$query" ]; then
            echo "$wt_path"
            return 0
        fi
        # ${repo_name}-${query} パターン
        if [ "$dir_name" = "${repo_name}-${query}" ]; then
            echo "$wt_path"
            return 0
        fi
        # PR worktree: parent が ${repo_name}-PR で basename が query
        # PR-123, #123, 123 いずれでもマッチ
        q="${query#PR-}"
        q="${q#\#}"
        if [ "$parent_name" = "${repo_name}-PR" ] && [ "$dir_name" = "$q" ]; then
            echo "$wt_path"
            return 0
        fi
    done
    return 1
}

# Helper function to extract PR number from URL or number
function _gw_extract_pr_number() {
    local input="$1"
    # URL: https://github.com/owner/repo/pull/123
    if [[ "$input" =~ ^https://github\.com/.+/pull/([0-9]+) ]]; then
        echo "${match[1]}"
    # #123 形式
    elif [[ "$input" =~ ^#([0-9]+)$ ]]; then
        echo "${match[1]}"
    # 数字のみ
    elif [[ "$input" =~ ^[0-9]+$ ]]; then
        echo "$input"
    else
        return 1
    fi
}

# Symlink .claude/ subdirectories from main to worktree
function _gw_symlink_claude_dirs() {
    local worktree_path="$1"
    local main_repo_path="$2"
    local claude_dirs=(commands skills agents hooks)

    [ ! -d "${main_repo_path}/.claude" ] && return 0

    local dir main_dir wt_dir wt_claude
    wt_claude="${worktree_path}/.claude"
    for dir in "${claude_dirs[@]}"; do
        main_dir="${main_repo_path}/.claude/${dir}"
        wt_dir="${wt_claude}/${dir}"

        # main側に存在しない → スキップ
        [ ! -d "$main_dir" ] && continue

        # gitignore対象でない → スキップ
        if ! git -C "$main_repo_path" check-ignore -q ".claude/${dir}" 2>/dev/null; then
            continue
        fi

        # 既にsymlink → スキップ（冪等）
        [ -L "$wt_dir" ] && continue

        # ディレクトリあり（中身あり） → 警告してスキップ
        if [ -d "$wt_dir" ]; then
            if [ -z "$(ls -A "$wt_dir" 2>/dev/null)" ]; then
                rmdir "$wt_dir"
            else
                echo "警告: ${wt_dir} は空でないためsymlinkをスキップします"
                continue
            fi
        fi

        mkdir -p "$wt_claude"
        ln -s "$main_dir" "$wt_dir"
    done
}

function _gw_setup_worktree() {
    local worktree_path="$1"
    shift
    local main_repo_path=$(git worktree list | head -n 1 | awk '{print $1}')

    _gw_symlink_claude_dirs "$worktree_path" "$main_repo_path"
    _gw_sync_files "$worktree_path" "$main_repo_path"

    if [ -x "${main_repo_path}/.gw.sh" ]; then
        echo "=== Running .gw.sh ==="
        "${main_repo_path}/.gw.sh" "$worktree_path"
        echo "=== Done .gw.sh ==="
    fi

    local key value
    for kv in "$@"; do
        key="${kv%%=*}"
        value="${kv#*=}"
        _gw_set_value "$worktree_path" "$key" "$value"
    done

    cd "$worktree_path"
}

# Check worktree status for prune candidates
# Returns comma-separated reasons or empty string if not a candidate
function _gw_check_worktree_status() {
    local worktree_path="$1"
    local branch=$(git -C "$worktree_path" branch --show-current 2>/dev/null)
    [ -z "$branch" ] && return 1

    local pr_number=$(_gw_get_value "$worktree_path" "pr_number")
    local reasons=()

    # Check: remote branch gone
    local remote_check
    remote_check=$(git ls-remote --heads origin "$branch" 2>/dev/null)
    if [ $? -ne 0 ]; then
        return 1
    fi
    if [ -z "$remote_check" ]; then
        reasons+=("branch gone")
    fi

    # Check: PR merged (by branch name)
    if command -v gh &> /dev/null; then
        local merged_check
        merged_check=$(gh pr list --state merged --head "$branch" --json number --jq '.[0].number' 2>/dev/null)
        if [ $? -ne 0 ]; then
            return 1
        fi
        if [ -n "$merged_check" ]; then
            reasons+=("merged")
        fi

        # PR-specific checks
        if [ -n "$pr_number" ]; then
            local pr_json
            pr_json=$(gh pr view "$pr_number" --json state,reviewDecision 2>/dev/null)
            if [ $? -ne 0 ]; then
                return 1
            fi

            local pr_state=$(echo "$pr_json" | jq -r '.state')
            local review_decision=$(echo "$pr_json" | jq -r '.reviewDecision')

            if [ "$pr_state" = "CLOSED" ]; then
                reasons+=("closed")
            fi
            if [ "$review_decision" = "APPROVED" ]; then
                reasons+=("approved")
            fi
        fi
    fi

    # Check: JIRA done (via cache)
    local jira_key=""
    if [[ "$branch" =~ ([A-Z]+-[0-9]+) ]]; then
        jira_key="${match[1]}"
    fi
    if [ -n "$jira_key" ]; then
        local main_repo_path=$(git worktree list | head -n 1 | awk '{print $1}')
        local cache_file="${main_repo_path}/.git/gw_jira_cache.json"
        if [ -f "$cache_file" ]; then
            local jira_status
            jira_status=$(jq -r --arg key "$jira_key" '.[$key] // empty' "$cache_file" 2>/dev/null)
            if [ "$jira_status" = "Done" ] || [ "$jira_status" = "done" ]; then
                reasons+=("jira done")
            fi
        fi
    fi

    if [ ${#reasons[@]} -eq 0 ]; then
        return 1
    fi

    local IFS=", "
    echo "${reasons[*]}"
    return 0
}

# Prune stale worktrees
function _gw_prune() {
    if ! command -v fzf &> /dev/null; then
        echo "エラー: fzf コマンドが見つかりません"
        return 1
    fi

    local main_repo_path=$(git worktree list | head -n 1 | awk '{print $1}')
    local repo_name=$(basename "$main_repo_path")
    local candidates=()

    local worktree_lines=(${(f)"$(git worktree list)"})
    local wt_path reason dir_name parent_name label purpose display
    for line in "${worktree_lines[@]}"; do
        wt_path=$(echo "$line" | awk '{print $1}')

        # Skip main worktree
        if [ "$wt_path" = "$main_repo_path" ]; then
            continue
        fi

        if ! reason=$(_gw_check_worktree_status "$wt_path"); then
            continue
        fi

        # Build label
        dir_name=$(basename "$wt_path")
        parent_name=$(basename "$(dirname "$wt_path")")
        if [[ "$parent_name" == "${repo_name}-PR" ]]; then
            label="PR-${dir_name}"
        elif [[ "$dir_name" == "${repo_name}-"* ]]; then
            label="${dir_name#${repo_name}-}"
        else
            label="$dir_name"
        fi

        purpose=$(_gw_get_description "$wt_path")
        [ -n "$purpose" ] && purpose=$(_gw_truncate_text "$purpose" 40)

        # Format: label  purpose  [reasons]  path
        display="${label}"
        [ -n "$purpose" ] && display="${display}\t${purpose}"
        display="${display}\t[${reason}]"

        candidates+=("${display}\t${wt_path}")
    done

    if [ ${#candidates[@]} -eq 0 ]; then
        echo "削除対象のworktreeはありません"
        return 0
    fi

    # fzf input: display columns separated by tab, last column is path (hidden)
    local selected
    selected=$(printf '%s\n' "${candidates[@]}" | \
        fzf --multi --bind 'start:select-all' \
            --header='Tab: toggle, Enter: delete selected, ESC: cancel' \
            --with-nth='1..-2' \
            --delimiter=$'\t')

    if [ -z "$selected" ]; then
        echo "キャンセルしました"
        return 0
    fi

    local selected_lines=(${(f)"$selected"})
    local wt_path branch
    for line in "${selected_lines[@]}"; do
        wt_path="${line##*$'\t'}"
        if [ -z "$wt_path" ] || [ ! -d "$wt_path" ]; then
            continue
        fi
        branch=$(git -C "$wt_path" branch --show-current 2>/dev/null)
        git worktree remove --force "$wt_path" && \
            echo "Worktree removed: $wt_path"
        if [[ -n "$branch" && "$branch" != "main" && "$branch" != "master" ]]; then
            git branch -D "$branch" 2>/dev/null && \
                echo "Branch deleted: $branch"
        fi
    done
}

function gw() {
    case "$1" in
        create|cr)
            shift
            _gw_create "$@"
            ;;
        list|ls)
            shift
            _gw_list "$@"
            ;;
        remove|rm)
            shift
            _gw_remove "$@"
            ;;
        switch|sw)
            shift
            _gw_switch "$@"
            ;;
        describe|desc)
            shift
            _gw_describe "$@"
            ;;
        pr)
            shift
            _gw_review "$@"
            ;;
        prune)
            shift
            _gw_prune "$@"
            ;;
        setup)
            shift
            _gw_setup_template "$@"
            ;;
        *)
            echo "Usage: gw <command> [options]"
            echo ""
            echo "Commands:"
            echo "  create, cr <task> <desc> Create worktree and switch to it"
            echo "  list, ls                 List all worktrees"
            echo "  remove, rm [task]        Remove worktree (no args = current)"
            echo "  switch, sw [task|-]      Switch to worktree (no args = main, - = previous)"
            echo "  describe, desc           Show worktree info"
            echo "    --set purpose=<text>   Set purpose"
            echo "  pr <pr|url>              Create worktree for PR review"
            echo "  prune                    Remove stale worktrees (merged, closed, etc.)"
            echo "  setup                    Install .gw.sh template to repository"
            ;;
    esac
}

# Create new worktree
function _gw_create() {
    local task_name="$1"
    local description="$2"
    if [ -z "$task_name" ]; then
        echo "エラー: タスク名を指定してください"
        return 1
    fi

    if [ -z "$description" ]; then
        echo -n "目的を入力してください: "
        read -r description
        if [ -z "$description" ]; then
            echo "エラー: 目的は必須です"
            return 1
        fi
    fi

    local branch_name="$task_name"

    # Check if local branch already exists
    local local_branch_exists=false
    if git show-ref --verify --quiet "refs/heads/${branch_name}"; then
        local_branch_exists=true
    fi

    # Check if we're in a git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo "エラー: gitリポジトリではありません"
        return 1
    fi

    # Get worktree path
    local worktree_path=$(_gw_get_worktree_path "$branch_name")
    local main_repo_path=$(git worktree list | head -n 1 | awk '{print $1}')

    # Check if worktree already exists
    if [ -d "$worktree_path" ]; then
        echo "Worktree already exists. Moving to: $worktree_path"
        cd "$worktree_path"
        return 0
    fi

    # Check if remote branch exists
    local remote_exists=false
    if git ls-remote --heads origin "$branch_name" | grep -q "$branch_name"; then
        remote_exists=true
    fi
    
    # Determine branch status and show message
    if [ "$local_branch_exists" = true ]; then
        echo "既存のローカルブランチ '$branch_name' からworktreeを作成します。"
    elif [ "$remote_exists" = true ]; then
        echo "リモートブランチ '$branch_name' が見つかりました。リモートブランチからworktreeを作成します。"
    else
        echo "新しいブランチ '$branch_name' としてworktreeを作成します。"
    fi

    # Update local main branch
    echo "Updating local main branch..."
    local main_checked_out=$(cd "$main_repo_path" && git branch --show-current)
    if [ "$main_checked_out" = "main" ]; then
        if ! (cd "$main_repo_path" && git pull origin main); then
            echo "エラー: ローカルmainの更新に失敗しました"
            return 1
        fi
    else
        if ! (cd "$main_repo_path" && git fetch origin main:main); then
            echo "エラー: ローカルmainの更新に失敗しました"
            return 1
        fi
    fi

    # Create worktree - use different command based on branch existence
    echo "Creating worktree: $worktree_path"
    if [ "$local_branch_exists" = true ]; then
        # Local branch exists, just checkout
        git worktree add "$worktree_path" "$branch_name"
    elif [ "$remote_exists" = true ]; then
        # Remote branch exists, track it without -b
        git worktree add "$worktree_path" "$branch_name"
    else
        # Create new branch from local main (no upstream set)
        git worktree add -b "$branch_name" "$worktree_path" main
    fi

    _gw_setup_worktree "$worktree_path" \
        "purpose=${description}" \
        "original_branch=${branch_name}"
    echo "Worktree created and switched to: $worktree_path"
}

# Helper function to format worktree info line
function _gw_format_worktree_line() {
    local worktree_path="$1"
    local branch="$2"
    local max_width="${3:-0}"
    local show_branch="${4:-auto}"

    local shortened_path=$(_shorten_path "$worktree_path")
    local purpose=$(_gw_get_description "$worktree_path")

    local dir_name=$(basename "$worktree_path")
    local branch_name="${branch#\[}"
    branch_name="${branch_name%\]}"

    # メインリポジトリの情報を取得
    local main_repo_path=$(git worktree list | head -n 1 | awk '{print $1}')
    local repo_name=$(basename "$main_repo_path")
    # 初期ブランチを取得
    local original_branch=$(_gw_get_value "$worktree_path" "original_branch")

    local prefix="$shortened_path"
    # メインリポジトリ + main ブランチの場合は非表示
    if [[ "$dir_name" == "$repo_name" ]] && [[ "$branch_name" == "main" ]]; then
        : # ブランチ表示しない
    # 初期ブランチと同じ場合も非表示
    elif [[ -n "$original_branch" ]] && [[ "$branch_name" == "$original_branch" ]]; then
        : # ブランチ表示しない
    elif [ "$show_branch" = "always" ] || { [ "$show_branch" = "auto" ] && [[ "$dir_name" != *"-${branch_name}" ]]; }; then
        prefix="${shortened_path} ${branch}"
    fi

    if [ "$max_width" -gt 0 ] && [ -n "$purpose" ]; then
        local prefix_len=${#prefix}
        local desc_max=$((max_width - prefix_len - 2))
        if [ $desc_max -gt 10 ]; then
            local truncated=$(_gw_truncate_text "$purpose" $desc_max)
            echo "${prefix} ${truncated}"
            return
        fi
    fi
    echo "$prefix"
}

# List worktrees
function _gw_list() {
    local term_width=${COLUMNS:-$(tput cols)}
    local lines=(${(f)"$(git worktree list)"})
    local worktree_path branch
    for line in "${lines[@]}"; do
        worktree_path=$(echo "$line" | awk '{print $1}')
        branch=$(echo "$line" | awk '{print $3}')
        _gw_format_worktree_line "$worktree_path" "$branch" "$term_width"
    done
}

# Remove worktree
function _gw_remove() {
    local task_name="$1"
    local main_repo_path=$(git worktree list | head -n 1 | awk '{print $1}')
    local current_path=$(pwd)
    local confirm_current=false

    local worktree_path

    if [ -z "$task_name" ]; then
        if [ "$current_path" = "$main_repo_path" ]; then
            echo "エラー: main worktree は削除できません"
            return 1
        fi
        # カレントディレクトリが worktree か確認
        if ! git worktree list | awk '{print $1}' | grep -qxF "$current_path"; then
            echo "エラー: 現在のディレクトリはworktreeではありません"
            return 1
        fi
        confirm_current=true
        worktree_path="$current_path"
    else
        worktree_path=$(_gw_resolve_worktree "$task_name")
        if [ $? -ne 0 ] || [ -z "$worktree_path" ]; then
            echo "エラー: Worktree '$task_name' が見つかりません"
            return 1
        fi
    fi

    shift 2>/dev/null
    local additional_args=("$@")

    if [ ! -d "$worktree_path" ]; then
        echo "エラー: Worktree '$worktree_path' が存在しません"
        return 1
    fi

    if [ "$confirm_current" = true ]; then
        echo -n "現在の worktree '$worktree_path' を削除しますか? [y/N]: "
        read -r response
        case "$response" in
            [Yy]|[Yy][Ee][Ss])
                ;;
            *)
                echo "Aborted"
                return 1
                ;;
        esac
    fi

    # Check if --force is already specified
    local has_force=false
    for arg in "${additional_args[@]}"; do
        if [[ "$arg" == "--force" || "$arg" == "-f" ]]; then
            has_force=true
            break
        fi
    done

    # If --force is not specified, check for untracked/modified files
    if [ "$has_force" = false ]; then
        local status_output
        status_output=$(git -C "$worktree_path" status -sb 2>/dev/null)
        local has_changes=false

        # Check if there are any changes (lines other than the branch line)
        if echo "$status_output" | grep -q "^[^#].*[AMD??]"; then
            has_changes=true
        fi

        if [ "$has_changes" = true ]; then
            echo "Worktree contains untracked or modified files:"
            echo "$status_output"
            echo ""
            echo -n "Delete anyway? [y/N]: "
            read -r response

            case "$response" in
                [Yy]|[Yy][Ee][Ss])
                    additional_args+=("--force")
                    ;;
                *)
                    echo "Aborted"
                    return 1
                    ;;
            esac
        fi
    fi

    local current_branch=$(git -C "$worktree_path" branch --show-current 2>/dev/null)

    cd "$main_repo_path"

    git worktree remove "${additional_args[@]}" "$worktree_path"
    echo "Worktree removed: $worktree_path"

    if [[ -n "$current_branch" && "$current_branch" != "main" && "$current_branch" != "master" ]]; then
        git branch -D "$current_branch" 2>/dev/null && \
            echo "Branch deleted: $current_branch"
    fi
}

# Switch to existing worktree
function _gw_switch() {
    local task_name="$1"
    local current_path=$(pwd)

    if [ "$task_name" = "-" ]; then
        if [ -z "$GW_PREVIOUS_WORKTREE" ]; then
            echo "エラー: 以前のワークツリーがありません"
            return 1
        fi
        local worktree_path="$GW_PREVIOUS_WORKTREE"
    else
        local worktree_path=$(_gw_resolve_worktree "$task_name")
        if [ $? -ne 0 ] || [ -z "$worktree_path" ]; then
            echo "エラー: Worktree '$task_name' が見つかりません"
            return 1
        fi
    fi

    if [ ! -d "$worktree_path" ]; then
        echo "エラー: Worktree '$worktree_path' が存在しません"
        return 1
    fi

    # Save current path as previous before switching
    export GW_PREVIOUS_WORKTREE="$current_path"

    cd "$worktree_path"
    echo "Switched to: $worktree_path"

    local description=$(_gw_get_description "$worktree_path")
    if [ -n "$description" ]; then
        echo "目的: $description"
    fi
}

# Create worktree for PR review
function _gw_review() {
    local input="$1"
    if [ -z "$input" ]; then
        echo "エラー: PR番号またはURLを指定してください"
        echo "使い方: gw pr <pr-number|url>"
        return 1
    fi

    if ! command -v gh &> /dev/null; then
        echo "エラー: gh コマンドが見つかりません"
        return 1
    fi

    local pr_number=$(_gw_extract_pr_number "$input")
    if [ -z "$pr_number" ]; then
        echo "エラー: PR番号を抽出できませんでした: $input"
        return 1
    fi

    local pr_info
    pr_info=$(gh pr view "$pr_number" --json number,title,headRefName,url 2>&1)
    if [ $? -ne 0 ]; then
        echo "エラー: PR情報の取得に失敗しました"
        echo "$pr_info"
        return 1
    fi

    local pr_title=$(echo "$pr_info" | jq -r '.title')
    local pr_branch=$(echo "$pr_info" | jq -r '.headRefName')
    local pr_url=$(echo "$pr_info" | jq -r '.url')

    local main_repo_path=$(git worktree list | head -n 1 | awk '{print $1}')
    local repo_name=$(basename "$main_repo_path")
    local parent_dir=$(dirname "$main_repo_path")
    local pr_container="${parent_dir}/${repo_name}-PR"
    local worktree_path="${pr_container}/${pr_number}"

    if [ -d "$worktree_path" ]; then
        echo "既存のworktreeに移動します: $worktree_path"
        cd "$worktree_path"
        return 0
    fi

    if [ ! -d "$pr_container" ]; then
        mkdir -p "$pr_container"
    fi

    echo "PRブランチをfetchしています..."
    if ! (cd "$main_repo_path" && git fetch origin "$pr_branch"); then
        echo "エラー: ブランチのfetchに失敗しました"
        return 1
    fi

    echo "Worktreeを作成しています: $worktree_path"
    if ! git worktree add "$worktree_path" "$pr_branch"; then
        echo "エラー: worktreeの作成に失敗しました"
        return 1
    fi

    _gw_setup_worktree "$worktree_path" \
        "purpose=#${pr_number}: ${pr_title}" \
        "original_branch=${pr_branch}" \
        "pr_number=${pr_number}" \
        "pr_title=${pr_title}" \
        "pr_url=${pr_url}"
    echo "PR #${pr_number} のworktreeを作成しました: $worktree_path"
    echo "タイトル: $pr_title"
}

# Copy files listed in .gw-sync-files from main to worktree
function _gw_sync_files() {
    local worktree_path="$1"
    local main_repo_path="$2"
    local sync_file="${main_repo_path}/.gw-sync-files"

    [ ! -f "$sync_file" ] && return 0

    local file
    for file in ${(f)"$(< "$sync_file")"}; do
        [[ "$file" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${file// }" ]] && continue
        [ ! -f "${main_repo_path}/${file}" ] && continue
        if [ -f "${worktree_path}/${file}" ]; then
            echo "既に存在します: ${file}"
            read -q "?上書きしますか? [y/N] " || { echo; continue; }
            echo
        fi
        mkdir -p "$(dirname "${worktree_path}/${file}")"
        cp "${main_repo_path}/${file}" "${worktree_path}/${file}"
    done
}

# Install .gw.sh template to repository root
function _gw_setup_template() {
    local main_repo_path=$(git worktree list | head -n 1 | awk '{print $1}')
    local template="${${(%):-%x}:A:h}/../templates/.gw.sh.template"

    if [ ! -f "$template" ]; then
        echo "エラー: テンプレートが見つかりません: $template"
        return 1
    fi

    cp -v "$template" "${main_repo_path}/.gw.sh"
    chmod +x "${main_repo_path}/.gw.sh"
}

# Show or set description for current worktree
function _gw_describe() {
    local current_path=$(pwd)

    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo "エラー: gitリポジトリではありません"
        return 1
    fi

    if [ "$1" = "--set" ]; then
        local key_value="$2"
        if [ -z "$key_value" ]; then
            echo "エラー: --set には key=value を指定してください"
            return 1
        fi

        local key="${key_value%%=*}"
        local value="${key_value#*=}"

        case "$key" in
            purpose|original_branch)
                if [ -z "$value" ]; then
                    echo "エラー: 値を指定してください"
                    return 1
                fi
                _gw_set_value "$current_path" "$key" "$value"
                echo "${key}を設定しました: $value"
                ;;
            *)
                echo "エラー: 不明なキー '$key'"
                echo "設定可能なキー: purpose, original_branch"
                return 1
                ;;
        esac
    else
        local branch=$(git branch --show-current)
        local purpose=$(_gw_get_description "$current_path")
        local original_branch=$(_gw_get_value "$current_path" "original_branch")
        local pr_number=$(_gw_get_value "$current_path" "pr_number")
        local pr_url=$(_gw_get_value "$current_path" "pr_url")

        echo "path: $current_path"
        echo "branch: $branch"
        echo "purpose: ${purpose:-（未設定）}"
        echo "original_branch: ${original_branch:-（未設定）}"
        if [ -n "$pr_number" ]; then
            echo "pr_number: $pr_number"
            echo "pr_url: $pr_url"
        fi
    fi
}

# Completion function
function _gw() {
    local -a subcommands
    local state

    subcommands=(
        'create:Create new worktree and switch to it'
        'cr:Create new worktree (alias)'
        'list:List all worktrees'
        'ls:List worktrees (alias)'
        'remove:Remove worktree'
        'rm:Remove worktree (alias)'
        'switch:Switch to worktree'
        'sw:Switch to worktree (alias)'
        'describe:Show or set description'
        'desc:Show or set description (alias)'
        'pr:Create worktree for PR review'
        'prune:Remove stale worktrees'
        'setup:Install .gw.sh template'
    )

    _arguments -C \
        '1: :->command' \
        '2: :->args'

    case $state in
        command)
            _describe -t commands 'gw subcommand' subcommands
            ;;
        args)
            case $words[2] in
                remove|rm|switch|sw)
                    _gw_worktree_tasks
                    ;;
                create|cr|pr)
                    ;;
            esac
            ;;
    esac
}

# Helper function to complete worktree task names
function _gw_worktree_tasks() {
    local -a tasks
    local main_repo_path repo_name

    main_repo_path=$(git worktree list 2>/dev/null | head -n 1 | awk '{print $1}')
    [[ -z "$main_repo_path" ]] && return

    repo_name=$(basename "$main_repo_path")
    tasks=("main")

    local worktree_paths=(${(f)"$(git worktree list 2>/dev/null | awk 'NR>1 {print $1}')"})
    local dir_name parent_name purpose wt_label
    for wt_path in "${worktree_paths[@]}"; do
        dir_name=$(basename "$wt_path")
        parent_name=$(basename "$(dirname "$wt_path")")
        purpose=$(_gw_get_description "$wt_path")

        if [[ "$parent_name" == "${repo_name}-PR" ]]; then
            wt_label="PR-${dir_name}"
        elif [[ "$dir_name" == "${repo_name}-"* ]]; then
            wt_label="${dir_name#${repo_name}-}"
        else
            wt_label="$dir_name"
        fi

        if [[ -n "$purpose" ]]; then
            tasks+=("${wt_label}:${purpose//:/\\:}")
        else
            tasks+=("$wt_label")
        fi
    done

    [[ ${#tasks[@]} -gt 0 ]] && _describe -t tasks 'worktree task' tasks
}

# Register completion
if (( $+functions[compdef] )); then
    compdef _gw gw
fi
