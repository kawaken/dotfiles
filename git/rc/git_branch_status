#!/usr/bin/env zsh
function get_git_branch_status() {
  local rev_info
  rev_info=$(git rev-parse --is-inside-work-tree --git-dir --abbrev-ref HEAD 2>/dev/null) || return 1
  local -a rev_lines=("${(@f)rev_info}")
  local git_dir="${rev_lines[2]}"
  local branch="${rev_lines[3]}"

  local remote ahead behind staged modified untracked email domain output
  local status_output special_state

  local is_worktree=false
  [[ "$git_dir" == *"/worktrees/"* ]] && is_worktree=true

  special_state=""
  local branch_from_status
  if [[ -d "$git_dir/rebase-merge" ]] || [[ -d "$git_dir/rebase-apply" ]]; then
    special_state="%F{magenta}REBASE%f"
    if [[ -f "$git_dir/rebase-merge/head-name" ]]; then
      branch_from_status=$(< "$git_dir/rebase-merge/head-name")
      branch_from_status="${branch_from_status#refs/heads/}"
    fi
  elif [[ -f "$git_dir/MERGE_HEAD" ]]; then
    special_state="%F{red}MERGE%f"
  elif [[ -f "$git_dir/CHERRY_PICK_HEAD" ]]; then
    special_state="%F{cyan}CHERRY-PICK%f"
  elif [[ -f "$git_dir/REVERT_HEAD" ]]; then
    special_state="%F{yellow}REVERT%f"
  fi

  if [[ -z "$branch" ]] || [[ "$branch" == "HEAD" ]]; then
    branch="${branch_from_status:-unknown}"
  fi

  remote=$(git rev-parse --verify "@{upstream}" --symbolic-full-name 2>/dev/null)
  remote="${remote#refs/remotes/}"

  if [[ -n "$remote" ]]; then
    local color="69"
    $is_worktree && color="cyan"

    if [[ "$branch" != "${remote#*/}" ]]; then
      branch="%F{${color}}${branch}%f-%F{yellow}${remote}%f"
    else
      branch="%F{${color}}${branch}%f"
    fi

    local lr
    lr=$(git rev-list --left-right --count "@{upstream}...HEAD" 2>/dev/null)
    behind="${lr%%	*}"
    ahead="${lr##*	}"

    if (( ahead > 0 )) || (( behind > 0 )); then
      output+=":"
    fi

    if (( ahead >= 10 )); then
      output+="%F{green}⇡*%f"
    elif (( ahead > 0 )); then
      output+="%F{green}⇡${ahead}%f"
    fi

    if (( behind >= 10 )); then
      output+="%F{red}⇣*%f"
    elif (( behind > 0 )); then
      output+="%F{red}⇣${behind}%f"
    fi
  elif $is_worktree; then
    branch="%F{cyan}${branch}%f"
  else
    branch="%F{202}${branch}%f"
  fi

  status_output=$(git status --porcelain 2>/dev/null)
  staged=0
  modified=0
  untracked=0
  conflicted=0

  if [[ -n "$status_output" ]]; then
    read staged modified untracked conflicted <<< $(
      echo "$status_output" | awk '{
        x = substr($0,1,1); y = substr($0,2,1)
        if (x=="U"||y=="U"||(x=="A"&&y=="A")||(x=="D"&&y=="D")) c++
        else if (x!=" "&&x!="?") s++
        if (y!=" "&&x!="?"&&y!="U") m++
        if (x=="?") u++
      } END { print s+0, m+0, u+0, c+0 }'
    )
  fi

  if [[ "$PWD" != "$_git_email_cache_dir" ]]; then
    _git_email_cache=$(git config user.email 2>/dev/null)
    _git_email_cache_dir="$PWD"
  fi
  email="$_git_email_cache"
  if [[ -n "$email" ]]; then
    domain="${email##*@}"
    domain="%F{magenta}${domain:0:2}%f"
  fi

  local final_output="%F{white}[%f${branch}${output}"

  if [[ -n "$special_state" ]]; then
    final_output+="|${special_state}"
  fi

  final_output+="%F{white}] %f"

  local file_status=""
  if (( conflicted > 0 )); then
    file_status+="%F{red}!${conflicted}%f"
  fi
  if (( staged > 0 )); then
    file_status+="%F{green}+${staged}%f"
  fi
  if (( modified > 0 )); then
    file_status+="%F{red}*${modified}%f"
  fi
  if (( untracked > 0 )); then
    file_status+="%F{yellow}?${untracked}%f"
  fi

  if [[ -n "$file_status" ]]; then
    final_output+="${file_status}"
  fi

  if [[ -n "$domain" ]]; then
    final_output+=" ${domain}"
  fi

  echo "
$final_output"
}

function _update_git_branch_status_msg() {
  local prompt

  prompt=$(get_git_branch_status)

  echo "$prompt"
}
